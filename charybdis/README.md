### üëæ Use Monstrous tandem of Scylla and Charybdis to build your next project
‚ö†Ô∏è **WIP: This project is currently in an early stage that utilizes rust nightly release**

<img src="https://www.scylladb.com/wp-content/uploads/scylla-opensource-1.png" height="250">

* Scylla: NoSQL DB focused on performance
* Charybdis: Thin layer  on top of `scylla_rust_driver` focused on easy of use and performance

### Usage considerations:
- Provide and expressive API for CRUD & Complex Query operations on model as a whole
- Provide easy way to manipulate model partially by using partial_model! macro
- Intelligent migration tool that analyzes the `model/*.rs` files and runs migrations according to differences between the model definition and database

### Performance consideration:
- It's build by nightly release, so it uses builtin support for `async/await` in traits
- It uses prepared statements (shard/token aware)
- CRUD query strings are constants generated by macros and not calculated at runtime
- While it has expressive API it's very thin layer on top of scylla_rust_driver, and it does not introduce any additional overhead

### Usage:

#### For Tables
Declare model as a struct within `src/models` dir: (Note we use `src/models` as migration tool expects that dir)
```rust
// src/modles/user.rs
use charybdis::prelude::*;
use super::udts::Address;

#[partial_model_generator] // required on top of the charybdis_model macro
#[charybdis_model(table_name = "users", partition_keys = ["id"], clustering_keys = [], secondary_indexes = [])]
pub struct User {
    pub id: Uuid,
    pub username: Text,
    pub password: Text,
    pub hashed_password: Text,
    pub email: Text,
    pub created_at: Timestamp,
    pub updated_at: Timestamp,
    pub address: Address,
}
```

#### For UDTs
Declare udt model as a struct within `src/models/udts` dir:
```rust
// src/models/udts/address.rs
use charybdis::prelude::*;

#[charybdis_udt_model(type_name = "address")]
pub struct Address {
    pub street: Text,
    pub city: Text,
    pub state: Text,
    pub zip: Text,
    pub country: Text,
}
```
#### For Materialized Views
Declare view model as a struct within `src/models/materialized_views` dir:

```rust
use charybdis::prelude::*;

#[charybdis_view_model(table_name="users_by_username", base_table="users", partition_keys=["username"], clustering_keys=["id"])]
pub struct UsersByUsername {
    pub username: Text,
    pub id: Uuid,
    pub email: Text,
    pub created_at: Timestamp,
    pub updated_at: Timestamp,
}
```
Resulting auto-gen migration query will be:
```sql
CREATE MATERIALIZED VIEW IF NOT EXISTS users_by_email
AS SELECT created_at, updated_at, username, email, id
FROM users
WHERE email IS NOT NULL AND id IS NOT NULL
PRIMARY KEY (email, id)
  ```

### Automatic migration with `charybdis_cmd/migrate`:
Smart migration tool that enables you to migrate your models to database without need to write migrations by hand.
It analyzes root crate `src/models` files and generates migrations based on differences between
model definition and database.

‚ö†Ô∏è If you are working with **existing** datasets, you need to make sure that your **model** definitions structure
matches the database in respect to table names, column names, column types, partition keys, clustering keys
and secondary indexes. If structure is matched, it will not run any migrations.

It supports following operations:
- Create new tables
- Create new columns
- Delete columns
- Create secondary indexes
- Delete secondary indexes
- Create UDTs (`src/models/udts`)
- Change UDTs
- Create materialized views (`src/models/materialized_views`)

Note that deletion of tables, views and UDTs is not supported.

It <b>will</b> delete columns, tables, indexes, etc. that are not defined in the model files
```bash
cargo install charybdis_cmd/migrate
migrate
```

### Basic Operations:

```rust
mod models;
use crate::models::user::*;

#[tokio::main]
async fn main() {
    let session = CachingSession::new(..);
    
    // find user
    let user = User::from_json(json);
    user.find_by_primary_key(&session).await;
    
    // create
    let user = User::from_json(json).insert(&session).await;
    
    // update
    let user = User::from_json(json);
    user.username = "new_username".to_string();
    user.update(&session).await;
    
    // delete
    let user = User::from_json(json).delete(&session).await;
}

```
### Partial Model Operations:
Use auto generated partial model macro to run operations on subset of the model fields.
This macro will generate a new struct with same structure as the original model, but with only subset of the fields.

<p style="color: #e4a47c">
Note: Partition key fields are required!
</p>

```rust
// auto-generated macro
partial_user!(PartialUser, id, username);

#[tokio::main]
async fn main() {
    // find by partial user
    let mut p_user = PartialUser { id: "uuid_str", username: "username".to_string() };
    p_user.find_by_primary_key(&session).await;
    
    let response_json = p_user.to_json();
    
    // update by partial user
    let p_user = PartialUser { id: user.id, username: user.username };
    p_user.update(&session).await;

    // For deleting a row we can use either base model struct or partial_model struct that has only primary key fields.
    // For deleting columns we can use partial_model struct that has only primary key fields and columns to be deleted.
    partial_user!(PartialUser, id);
    
    let mut p_user = PartialUser { id: user.id };
    p_user.delete(&session).await;
}
```


### Future Plans:
- Add query builder and dervies for many possible query variations on primary_key fields:`Like`, `Contains`, `In`, `NotIn`, `Between`, `NotBetween`, `GreaterThan`, `LessThan`, `GreaterThanOrEqual`, `LessThanOrEqual`, `NotEqual`, `Equal`, `NotLike`, `NotContains`, `NotIn`, `NotBetween`, `NotGreaterThan`, `NotLessThan`, `NotGreaterThanOrEqual`, `NotLessThanOrEqual`...
- This way we have many possible queries as constants, and we don't need to generate them at runtime
